/*
 * Copyright (c) 2018.
 *
 * This file is part of ProcessManager.
 *
 * ProcessManager is free software: you can redistribute it and/or modify it under the terms of version 3 of the
 * GNU Lesser General Public License as published by the Free Software Foundation.
 *
 * ProcessManager is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with ProcessManager.  If not,
 * see <http://www.gnu.org/licenses/>.
 */

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2009.09.24 at 08:12:58 PM CEST
//


package nl.adaptivity.xml.serialization.regressions.soap

import kotlinx.serialization.*
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.MapSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.buildClassSerialDescriptor
import kotlinx.serialization.descriptors.element
import kotlinx.serialization.encoding.*
import nl.adaptivity.xmlutil.*
import nl.adaptivity.xmlutil.serialization.XML
import nl.adaptivity.xmlutil.util.CompactFragment
import nl.adaptivity.xmlutil.util.CompactFragmentSerializer


/**
 * Elements replacing the wildcard MUST be namespace qualified, but can be in
 * the targetNamespace
 *
 *
 * Java class for Header complex type.
 *
 *
 * The following schema fragment specifies the expected content contained within
 * this class.
 *
 * ```
 * <complexType name="Header">
 * <complexContent>
 * <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 * <sequence>
 * <any processContents='lax' maxOccurs="unbounded" minOccurs="0"/>
 * </sequence>
 * <anyAttribute processContents='lax' namespace='##other'/>
 * </restriction>
 * </complexContent>
 * </complexType>
 *
 */
@Serializable(Header.Companion::class)
class Header(
    val blocks: List<Block<Any>> = emptyList(),
    val encodingStyle: String? = null,
    val otherAttributes: Map<QName, String> = emptyMap()
) {
    @Transient
    var principal: String? = null
        private set

    sealed class Block<out T : Any> {
        abstract fun get(): T

        abstract internal fun toCompactFragment(): CompactFragment
    }

    class SupportedBlock<T : Any>(val data: T, val serializer: KSerializer<T>) : Block<T>() {
        override fun get(): T = data

        override fun toCompactFragment(): CompactFragment {
            val s: SerializationStrategy<T> = serializer
            return CompactFragment(XML.encodeToString<T>(s, value = data))
        }

        companion object {
            inline operator fun <reified T : Any> invoke(data: T): SupportedBlock<T> {
                val serializer = serializer<T>()
                return SupportedBlock(data, serializer)
            }
        }
    }

    class UnsupportedBlock(val xml: CompactFragment) : Block<CompactFragment>() {
        override fun get(): CompactFragment = xml
        override fun toCompactFragment(): CompactFragment = xml
    }

    companion object : KSerializer<Header> {
        private val blockSerializer = ListSerializer(CompactFragmentSerializer)
        private val otherAttrsSerializer = MapSerializer(QNameSerializer, String.serializer())

        @OptIn(ExperimentalSerializationApi::class, XmlUtilInternal::class)
        override val descriptor: SerialDescriptor = buildClassSerialDescriptor("org.w3c.dom.Header") {
            annotations = SoapSerialObjects.headerAnnotations
            element<String>("encodingStyle", SoapSerialObjects.encodingStyleAnnotations, true)
            element("otherAttributes", otherAttrsSerializer.descriptor, isOptional = true)
            element("blocks", blockSerializer.descriptor)
        }

        override fun deserialize(decoder: Decoder): Header {
            var encodingStyle: String? = null
            var otherAttributes: Map<QName, String> = emptyMap()
            lateinit var blocks: List<Block<Any>>
            decoder.decodeStructure(descriptor) {
                if (decoder is XML.XmlInput) {
                    val reader: XmlReader = decoder.input
                    otherAttributes = reader.attributes.filter {
                        when {
                            it.prefix == XMLConstants.XMLNS_ATTRIBUTE ||
                                    (it.prefix == "" && it.localName == XMLConstants.XMLNS_ATTRIBUTE) -> false

                            it.namespaceUri != Envelope.NAMESPACE -> true
                            it.localName == "encodingStyle" -> {
                                encodingStyle = it.value; false
                            }

                            else -> true
                        }
                    }.associate { QName(it.namespaceUri, it.localName, it.prefix) to it.value }
                    val myBlocks = mutableListOf<Block<Any>>()
                    while (reader.nextTag() != EventType.END_ELEMENT) {
                        // TODO handle "supported header elements"
                        val cf = reader.elementContentToFragment().let {
                            it as? CompactFragment ?: CompactFragment(it)
                        }
                        myBlocks.add(UnsupportedBlock(cf))
                    }
                    blocks = myBlocks
                } else {
                    // TODO handle "supported header elements"
                    var idx: Int
                    while (decodeElementIndex(descriptor).also { idx = it } != CompositeDecoder.DECODE_DONE) {
                        when (idx) {
                            0 -> encodingStyle = decodeStringElement(descriptor, idx)
                            1 -> otherAttributes =
                                decodeSerializableElement(descriptor, idx, otherAttrsSerializer, otherAttributes)

                            2 -> blocks = decodeSerializableElement(
                                descriptor,
                                idx,
                                ListSerializer(CompactFragmentSerializer)
                            ).map { UnsupportedBlock(it) }
                        }
                    }
                }
            }
            return Header(blocks, encodingStyle, otherAttributes)
        }

        override fun serialize(encoder: Encoder, value: Header) {
            encoder.encodeStructure(descriptor) {
                value.encodingStyle?.also { style ->
                    encodeStringElement(descriptor, 0, style)
                }
                if (value.otherAttributes.isNotEmpty()) {
                    encodeSerializableElement(descriptor, 1, otherAttrsSerializer, value.otherAttributes)
                }
                // TODO optimize this for xml
                val blocks = value.blocks.map(Block<Any>::toCompactFragment)
                encodeSerializableElement(descriptor, 2, blockSerializer, blocks)
            }
        }

        const val ELEMENTLOCALNAME = "Header"
        val ELEMENTNAME = QName(Envelope.NAMESPACE, ELEMENTLOCALNAME, Envelope.PREFIX)
        const val PRINCIPALLOCALNAME = "principal"
        val PRINCIPALQNAME = QName("urn:principal", "principal", "pm")
    }

}

class BlockSerializer<T: Any>(private val elementSerializer: KSerializer<T>): XmlSerializer<Header.Block<T>> {
    override val descriptor: SerialDescriptor =
        SerialDescriptor("Soap.Header.Block", CompactFragment.serializer().descriptor)

    override fun deserialize(decoder: Decoder): Header.Block<T> {
        val cf = CompactFragment.serializer().deserialize(decoder)
        @Suppress("UNCHECKED_CAST")
        return Header.UnsupportedBlock(cf) as Header.Block<T>
    }

    override fun deserializeXML(
        decoder: Decoder,
        input: XmlReader,
        previousValue: Header.Block<T>?,
        isValueChild: Boolean
    ): Header.Block<T> {
        return deserialize(decoder) // support "known" blocks
    }

    override fun serializeXML(encoder: Encoder, output: XmlWriter, value: Header.Block<T>, isValueChild: Boolean) {
        serialize(encoder, value) // no special treatment
    }

    override fun serialize(encoder: Encoder, value: Header.Block<T>) {
        when (value) {
            is Header.SupportedBlock -> value.serializer.serialize(encoder, value.data)

            else -> CompactFragment.serializer().serialize(encoder, value.toCompactFragment())
        }
    }
}
